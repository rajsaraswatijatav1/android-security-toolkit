#!/usr/bin/env python3
"""
ANDROID SECURITY TOOLKIT v2.0 - LEGAL NOTICE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
AUTHORIZED USE ONLY. PROHIBITED: Unauthorized access, spying, data theft.
REQUIRES: Device ownership OR written permission. VIOLATION: 5 years imprisonment.
--consent flag mandatory. All actions logged to loot/audit.log.
BY USING THIS TOOL, YOU ACCEPT FULL LEGAL RESPONSIBILITY.
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
"""

import subprocess
import re
import json
from typing import Dict, List, Optional, Any
from pathlib import Path

from core.base_scanner import BaseScanner


class VulnerabilityScanner(BaseScanner):
    """
    Comprehensive vulnerability scanner for Android devices.
    
    Scans for:
    - System app vulnerabilities
    - Security patch levels
    - Root exploits
    - ADB misconfigurations
    - Installed app risks
    - CVE correlations
    """
    
    # Known Android CVEs with detailed information
    ANDROID_CVES = {
        "CVE-2016-5195": {
            "title": "Dirty COW",
            "severity": "CRITICAL",
            "cvss_score": 7.8,
            "description": "Race condition in Linux kernel memory management",
            "affected_versions": ["3.4.0", "3.4.1", "3.4.2", "3.4.3", "3.4.4", "3.4.5"],
            "patches": ["2016-12-01", "2017-01-01"],
            "exploit_available": True,
            "remediation": "Update to latest Android security patch"
        },
        "CVE-2017-13274": {
            "title": "Broadcom Wi-Fi RCE",
            "severity": "HIGH",
            "cvss_score": 8.3,
            "description": "Remote code execution in Broadcom Wi-Fi chipset",
            "affected_versions": ["7.0", "7.1.1", "7.1.2", "8.0", "8.1"],
            "patches": ["2018-04-01"],
            "exploit_available": True,
            "remediation": "Update to latest security patch level"
        },
        "CVE-2020-0041": {
            "title": "Binder Use-After-Free",
            "severity": "CRITICAL",
            "cvss_score": 8.1,
            "description": "Use-after-free in binder driver",
            "affected_versions": ["8.0", "8.1", "9", "10"],
            "patches": ["2020-03-01"],
            "exploit_available": True,
            "remediation": "Apply Android security patch March 2020 or later"
        },
        "CVE-2021-0316": {
            "title": "System UI Privilege Escalation",
            "severity": "HIGH",
            "cvss_score": 7.0,
            "description": "Privilege escalation in System UI component",
            "affected_versions": ["8.1", "9", "10", "11"],
            "patches": ["2021-02-01"],
            "exploit_available": False,
            "remediation": "Update to Android 11 or apply security patch"
        },
        "CVE-2021-0682": {
            "title": "MediaCodec Out-of-Bounds Write",
            "severity": "CRITICAL",
            "cvss_score": 9.8,
            "description": "Out-of-bounds write in MediaCodec",
            "affected_versions": ["8.1", "9", "10", "11"],
            "patches": ["2021-08-01"],
            "exploit_available": True,
            "remediation": "Apply Android security patch August 2021 or later"
        },
        "CVE-2022-20465": {
            "title": "Lock Screen Bypass",
            "severity": "HIGH",
            "cvss_score": 6.8,
            "description": "Lock screen bypass without user interaction",
            "affected_versions": ["10", "11", "12", "12L"],
            "patches": ["2022-11-01"],
            "exploit_available": True,
            "remediation": "Update to Android 13 or apply security patch"
        },
        "CVE-2023-20963": {
            "title": "System Privilege Escalation",
            "severity": "HIGH",
            "cvss_score": 7.8,
            "description": "Privilege escalation in system service",
            "affected_versions": ["11", "12", "12L", "13"],
            "patches": ["2023-03-01"],
            "exploit_available": False,
            "remediation": "Apply Android security patch March 2023 or later"
        },
        "CVE-2023-2136": {
            "title": "Skia Remote Code Execution",
            "severity": "CRITICAL",
            "cvss_score": 9.6,
            "description": "Remote code execution in Skia graphics library",
            "affected_versions": ["11", "12", "12L", "13"],
            "patches": ["2023-06-01"],
            "exploit_available": True,
            "remediation": "Apply Android security patch June 2023 or later"
        }
    }
    
    # Root exploit indicators
    ROOT_EXPLOITS = [
        {
            "name": "Magisk",
            "indicators": ["magisk", "/sbin/magisk", "/system/bin/magisk"],
            "files": ["/sbin/magisk", "/system/bin/magisk", "/data/adb/magisk"]
        },
        {
            "name": "SuperSU",
            "indicators": ["supersu", "superuser", "/system/bin/su"],
            "files": ["/system/bin/su", "/system/xbin/su", "/sbin/su"]
        },
        {
            "name": "KingRoot",
            "indicators": ["kingroot", "kinguser"],
            "files": ["/system/bin/kinguser", "/system/xbin/kinguser"]
        },
        {
            "name": "Towelroot",
            "indicators": ["towelroot"],
            "files": []
        }
    ]
    
    # Suspicious system apps
    SUSPICIOUS_SYSTEM_APPS = [
        "com.android.system.ui",
        "com.android.settings",
        "com.android.phone",
        "com.android.providers.telephony",
        "com.android.providers.contacts",
        "com.android.providers.media",
        "com.android.location.fused",
        "com.android.inputmethod.latin"
    ]
    
    def __init__(self, device_id: Optional[str] = None):
        """
        Initialize vulnerability scanner.
        
        Args:
            device_id: Target device ID
        """
        super().__init__("VulnerabilityScanner", device_id=device_id)
        self.has_root = False
        self.android_version = None
        self.security_patch = None
        self.vulnerabilities = []
    
    def scan(self) -> Dict[str, Any]:
        """
        Perform comprehensive vulnerability scan.
        
        Returns:
            Dictionary containing scan results
        """
        self.logger.info("Starting vulnerability scan")
        
        try:
            # Phase 1: Gather system information
            self._gather_system_info()
            
            # Phase 2: Scan system apps
            self._scan_system_apps()
            
            # Phase 3: Check security patch level
            self._check_security_patch()
            
            # Phase 4: Detect root exploits
            self._detect_root_exploits()
            
            # Phase 5: Verify ADB settings
            self._verify_adb_settings()
            
            # Phase 6: Scan installed apps
            self._scan_installed_apps()
            
            # Phase 7: Correlate CVEs
            self._correlate_cves()
            
            # Generate summary
            summary = self._generate_vulnerability_summary()
            
            return summary
            
        except Exception as e:
            self.logger.error(f"Vulnerability scan failed: {e}")
            self.log_finding(
                "ERROR",
                "Vulnerability Scan Failed",
                f"Vulnerability scan failed with error: {str(e)}",
                {"error": str(e)},
                "Check logs and retry scan"
            )
            return self._generate_vulnerability_summary()
    
    def _gather_system_info(self) -> None:
        """Gather basic system information."""
        self.logger.info("Gathering system information")
        
        try:
            # Get Android version
            result = subprocess.run(
                ["adb", "-s", self.device_id, "shell", "getprop", "ro.build.version.release"],
                capture_output=True, text=True, timeout=10
            )
            
            if result.returncode == 0:
                self.android_version = result.stdout.strip()
                self.logger.info(f"Android version: {self.android_version}")
            
            # Get security patch level
            result = subprocess.run(
                ["adb", "-s", self.device_id, "shell", "getprop", "ro.build.version.security_patch"],
                capture_output=True, text=True, timeout=10
            )
            
            if result.returncode == 0:
                self.security_patch = result.stdout.strip()
                self.logger.info(f"Security patch: {self.security_patch}")
            
            # Check for root access
            result = subprocess.run(
                ["adb", "-s", self.device_id, "shell", "su", "-c", "id"],
                capture_output=True, text=True, timeout=10
            )
            
            self.has_root = result.returncode == 0 and "uid=0" in result.stdout
            
            # Log system info
            self.log_finding(
                "INFO",
                f"System Info: Android {self.android_version}",
                f"Device running Android {self.android_version}, Security patch: {self.security_patch}",
                {
                    "android_version": self.android_version,
                    "security_patch": self.security_patch,
                    "has_root": self.has_root
                },
                "System information gathered for vulnerability assessment"
            )
            
        except Exception as e:
            self.logger.error(f"System info gathering error: {e}")
    
    def _scan_system_apps(self) -> List[Dict[str, Any]]:
        """Scan system apps for vulnerabilities."""
        self.logger.info("Scanning system apps")
        
        system_apps = []
        
        try:
            # Get system apps
            result = subprocess.run(
                ["adb", "-s", self.device_id, "shell", "pm", "list", "packages", "-s"],
                capture_output=True, text=True, timeout=30
            )
            
            if result.returncode == 0:
                packages = result.stdout.strip().split('\n')
                
                for package_line in packages:
                    if package_line.startswith('package:'):
                        package_name = package_line[8:]  # Remove 'package:' prefix
                        
                        # Get app details
                        app_info = self._get_app_details(package_name)
                        
                        if app_info:
                            # Check for known vulnerable system apps
                            if self._check_vulnerable_system_app(package_name, app_info):
                                self.log_finding(
                                    "HIGH",
                                    f"Vulnerable System App: {package_name}",
                                    f"System app {package_name} may have known vulnerabilities",
                                    app_info,
                                    "Update system apps or apply security patches"
                                )
                            
                            system_apps.append(app_info)
            
            self.logger.info(f"Scanned {len(system_apps)} system apps")
            
            # Log summary
            self.log_finding(
                "INFO",
                f"System Apps Scan Complete: {len(system_apps)} apps",
                f"Scanned {len(system_apps)} system applications",
                {"count": len(system_apps)},
                "System apps scanned for vulnerabilities"
            )
            
        except Exception as e:
            self.logger.error(f"System apps scan error: {e}")
        
        return system_apps
    
    def _get_app_details(self, package_name: str) -> Optional[Dict[str, Any]]:
        """Get detailed information about an app."""
        try:
            result = subprocess.run(
                ["adb", "-s", self.device_id, "shell", "dumpsys", "package", package_name],
                capture_output=True, text=True, timeout=10
            )
            
            if result.returncode != 0:
                return None
            
            output = result.stdout
            
            # Parse app information
            app_info = {
                "package_name": package_name,
                "version_name": self._extract_field(output, r'versionName=([^\s]+)'),
                "version_code": self._extract_field(output, r'versionCode=([^\s]+)'),
                "target_sdk": self._extract_field(output, r'targetSdk=([^\s]+)'),
                "is_system_app": "/system/" in output,
                "is_enabled": "enabled=" in output,
                "is_debuggable": "DEBUGGABLE" in output,
                "permissions": []
            }
            
            # Extract permissions
            permission_matches = re.findall(r'android\.permission\.[^\s]+', output)
            app_info["permissions"] = list(set(permission_matches))
            
            return app_info
            
        except Exception as e:
            self.logger.debug(f"App details error for {package_name}: {e}")
            return None
    
    def _extract_field(self, text: str, pattern: str) -> str:
        """Extract field from text using regex."""
        match = re.search(pattern, text)
        return match.group(1) if match else "Unknown"
    
    def _check_vulnerable_system_app(self, package_name: str, app_info: Dict[str, Any]) -> bool:
        """Check if system app has known vulnerabilities."""
        # Check for old versions of critical system apps
        vulnerable_apps = {
            "com.android.system.ui": {"min_version": "10.0"},
            "com.android.settings": {"min_version": "10.0"},
            "com.android.phone": {"min_version": "10.0"},
        }
        
        if package_name in vulnerable_apps:
            # Simple version check - could be more sophisticated
            version = app_info.get("version_name", "0.0")
            if self._is_version_older(version, vulnerable_apps[package_name]["min_version"]):
                return True
        
        return False
    
    def _is_version_older(self, version1: str, version2: str) -> bool:
        """Compare version strings."""
        try:
            v1_parts = [int(x) for x in version1.split('.')]
            v2_parts = [int(x) for x in version2.split('.')]
            
            # Pad shorter version with zeros
            max_len = max(len(v1_parts), len(v2_parts))
            v1_parts.extend([0] * (max_len - len(v1_parts)))
            v2_parts.extend([0] * (max_len - len(v2_parts)))
            
            return v1_parts < v2_parts
        except Exception:
            return False
    
    def _check_security_patch(self) -> None:
        """Check security patch level for known vulnerabilities."""
        self.logger.info("Checking security patch level")
        
        if not self.security_patch:
            self.logger.warning("Security patch level not available")
            return
        
        try:
            # Parse patch date
            patch_year, patch_month, _ = self.security_patch.split('-')
            patch_date = int(patch_year + patch_month)
            
            # Check against CVE patch dates
            for cve_id, cve_info in self.ANDROID_CVES.items():
                for patch_date_str in cve_info.get("patches", []):
                    cve_year, cve_month, _ = patch_date_str.split('-')
                    cve_patch_date = int(cve_year + cve_month)
                    
                    if patch_date < cve_patch_date:
                        # Device is vulnerable
                        self.vulnerabilities.append({
                            "cve_id": cve_id,
                            "title": cve_info["title"],
                            "severity": cve_info["severity"],
                            "cvss_score": cve_info["cvss_score"],
                            "description": cve_info["description"],
                            "remediation": cve_info["remediation"],
                            "device_patch": self.security_patch,
                            "required_patch": patch_date_str
                        })
                        
                        self.log_finding(
                            cve_info["severity"],
                            f"{cve_id}: Security Patch Missing",
                            f"Device vulnerable to {cve_info['title']} - patch required: {patch_date_str}",
                            {
                                "cve_id": cve_id,
                                "current_patch": self.security_patch,
                                "required_patch": patch_date_str,
                                "cvss_score": cve_info["cvss_score"]
                            },
                            cve_info["remediation"],
                            cvss_score=cve_info["cvss_score"],
                            cve_id=cve_id
                        )
            
            self.logger.info(f"Security patch check complete: {len(self.vulnerabilities)} CVEs found")
            
        except Exception as e:
            self.logger.error(f"Security patch check error: {e}")
    
    def _detect_root_exploits(self) -> List[Dict[str, Any]]:
        """Detect root exploits and indicators."""
        self.logger.info("Detecting root exploits")
        
        detected_exploits = []
        
        try:
            # Check for root exploit indicators
            for exploit in self.ROOT_EXPLOITS:
                exploit_detected = False
                detected_indicators = []
                
                # Check for indicator strings
                for indicator in exploit["indicators"]:
                    result = subprocess.run(
                        ["adb", "-s", self.device_id, "shell", "grep", "-r", indicator, "/system", "2>/dev/null"],
                        capture_output=True, text=True, timeout=30
                    )
                    
                    if result.returncode == 0 and result.stdout:
                        exploit_detected = True
                        detected_indicators.append(f"String: {indicator}")
                
                # Check for exploit files
                for file_path in exploit["files"]:
                    result = subprocess.run(
                        ["adb", "-s", self.device_id, "shell", "ls", file_path],
                        capture_output=True, text=True, timeout=5
                    )
                    
                    if result.returncode == 0:
                        exploit_detected = True
                        detected_indicators.append(f"File: {file_path}")
                
                if exploit_detected:
                    exploit_info = {
                        "name": exploit["name"],
                        "indicators": detected_indicators,
                        "severity": "HIGH" if exploit["name"] in ["Magisk", "SuperSU"] else "MEDIUM"
                    }
                    
                    detected_exploits.append(exploit_info)
                    
                    self.log_finding(
                        exploit_info["severity"],
                        f"Root Exploit Detected: {exploit['name']}",
                        f"Device has {exploit['name']} root exploit indicators",
                        exploit_info,
                        "Remove root exploits for enhanced security"
                    )
            
            # Check for custom recovery
            result = subprocess.run(
                ["adb", "-s", self.device_id, "shell", "ls", "/recovery/"],
                capture_output=True, text=True, timeout=5
            )
            
            if result.returncode == 0:
                detected_exploits.append({
                    "name": "Custom Recovery",
                    "indicators": ["Custom recovery installed"],
                    "severity": "MEDIUM"
                })
                
                self.log_finding(
                    "MEDIUM",
                    "Custom Recovery Detected",
                    "Device has custom recovery installed",
                    {"recovery": "custom"},
                    "Custom recovery may indicate rooted device"
                )
            
            self.logger.info(f"Root exploit detection complete: {len(detected_exploits)} found")
            
        except Exception as e:
            self.logger.error(f"Root exploit detection error: {e}")
        
        return detected_exploits
    
    def _verify_adb_settings(self) -> Dict[str, Any]:
        """Verify ADB security settings."""
        self.logger.info("Verifying ADB security settings")
        
        adb_settings = {
            "adb_enabled": True,
            "secure_adb": True,
            "issues": []
        }
        
        try:
            # Check if ADB is enabled (we know it is since we're connected)
            result = subprocess.run(
                ["adb", "-s", self.device_id, "shell", "settings", "get", "global", "adb_enabled"],
                capture_output=True, text=True, timeout=5
            )
            
            if result.returncode == 0:
                adb_enabled = result.stdout.strip()
                adb_settings["adb_setting"] = adb_enabled
                
                if adb_enabled != "1":
                    adb_settings["issues"].append("ADB not enabled in settings")
            
            # Check secure boot setting
            result = subprocess.run(
                ["adb", "-s", self.device_id, "shell", "getprop", "ro.secure"],
                capture_output=True, text=True, timeout=5
            )
            
            if result.returncode == 0:
                secure_boot = result.stdout.strip()
                adb_settings["secure_boot"] = secure_boot
                
                if secure_boot == "0":
                    adb_settings["secure_adb"] = False
                    adb_settings["issues"].append("Secure boot disabled")
                    
                    self.log_finding(
                        "HIGH",
                        "Secure Boot Disabled",
                        "Device has secure boot disabled",
                        {"ro_secure": secure_boot},
                        "Enable secure boot for enhanced security"
                    )
            
            # Check USB debugging authorization
            result = subprocess.run(
                ["adb", "-s", self.device_id, "shell", "ls", "/data/misc/adb/adb_keys"],
                capture_output=True, text=True, timeout=5
            )
            
            if result.returncode == 0:
                adb_settings["authorized_keys"] = True
                
                # Count authorized keys
                key_count = len(result.stdout.strip().split('\n'))
                adb_settings["authorized_key_count"] = key_count
                
                if key_count > 5:
                    adb_settings["issues"].append("Too many authorized ADB keys")
                    
                    self.log_finding(
                        "MEDIUM",
                        "Multiple ADB Authorizations",
                        f"Device has {key_count} authorized ADB keys",
                        {"key_count": key_count},
                        "Review and remove unnecessary ADB authorizations"
                    )
            
            # Log ADB settings
            if not adb_settings["secure_adb"]:
                self.log_finding(
                    "MEDIUM",
                    "ADB Security Issues",
                    "ADB security configuration has issues",
                    adb_settings,
                    "Review and secure ADB configuration"
                )
            
            self.logger.info("ADB settings verification complete")
            
        except Exception as e:
            self.logger.error(f"ADB settings verification error: {e}")
        
        return adb_settings
    
    def _scan_installed_apps(self) -> List[Dict[str, Any]]:
        """Scan installed apps for risks."""
        self.logger.info("Scanning installed apps")
        
        installed_apps = []
        risky_apps = []
        
        try:
            # Get all installed apps
            result = subprocess.run(
                ["adb", "-s", self.device_id, "shell", "pm", "list", "packages", "-f"],
                capture_output=True, text=True, timeout=30
            )
            
            if result.returncode == 0:
                packages = result.stdout.strip().split('\n')
                
                for package_line in packages:
                    if package_line.startswith('package:'):
                        parts = package_line[8:].split('=')
                        if len(parts) == 2:
                            package_name = parts[1]
                            
                            # Get app details
                            app_info = self._get_app_details(package_name)
                            
                            if app_info:
                                # Check for risky apps
                                risk_score = self._calculate_app_risk(app_info)
                                app_info["risk_score"] = risk_score
                                
                                if risk_score > 5:
                                    risky_apps.append(app_info)
                                    
                                    self.log_finding(
                                        "MEDIUM",
                                        f"Risky App: {package_name}",
                                        f"App {package_name} has risk score {risk_score}/10",
                                        app_info,
                                        "Review app permissions and consider removal"
                                    )
                                
                                installed_apps.append(app_info)
            
            self.logger.info(f"Scanned {len(installed_apps)} apps, {len(risky_apps)} risky")
            
            # Log summary
            self.log_finding(
                "INFO",
                f"Installed Apps Scan Complete: {len(installed_apps)} apps",
                f"Scanned {len(installed_apps)} installed applications, found {len(risky_apps)} risky",
                {
                    "total_apps": len(installed_apps),
                    "risky_apps": len(risky_apps)
                },
                "Review risky applications"
            )
            
        except Exception as e:
            self.logger.error(f"Installed apps scan error: {e}")
        
        return installed_apps
    
    def _calculate_app_risk(self, app_info: Dict[str, Any]) -> int:
        """Calculate risk score for an app."""
        risk_score = 0
        
        # Check permissions
        permissions = app_info.get("permissions", [])
        high_risk_permissions = [
            "android.permission.SEND_SMS",
            "android.permission.CALL_PHONE",
            "android.permission.RECORD_AUDIO",
            "android.permission.CAMERA",
            "android.permission.ACCESS_FINE_LOCATION",
            "android.permission.READ_CONTACTS",
            "android.permission.READ_SMS"
        ]
        
        for perm in permissions:
            if perm in high_risk_permissions:
                risk_score += 2
        
        # Check if debuggable
        if app_info.get("is_debuggable", False):
            risk_score += 3
        
        # Check if system app
        if app_info.get("is_system_app", False):
            risk_score -= 1  # System apps are generally safer
        
        # Check target SDK (older SDKs may have security issues)
        target_sdk = app_info.get("target_sdk", "0")
        try:
            if int(target_sdk) < 28:  # Android 9.0
                risk_score += 2
        except ValueError:
            pass
        
        return max(0, min(10, risk_score))  # Ensure 0-10 range
    
    def _correlate_cves(self) -> None:
        """Correlate device with known CVEs."""
        self.logger.info("Correlating with known CVEs")
        
        # This is already done in _check_security_patch
        # Additional CVE correlation could be done here
        
        self.logger.info(f"CVE correlation complete: {len(self.vulnerabilities)} vulnerabilities found")
    
    def _generate_vulnerability_summary(self) -> Dict[str, Any]:
        """Generate vulnerability summary."""
        summary = {
            "scan_timestamp": time.time(),
            "device_id": self.device_id,
            "android_version": self.android_version,
            "security_patch": self.security_patch,
            "has_root": self.has_root,
            "vulnerabilities": self.vulnerabilities,
            "vulnerability_count": len(self.vulnerabilities),
            "critical_count": sum(1 for v in self.vulnerabilities if v["severity"] == "CRITICAL"),
            "high_count": sum(1 for v in self.vulnerabilities if v["severity"] == "HIGH"),
            "medium_count": sum(1 for v in self.vulnerabilities if v["severity"] == "MEDIUM"),
            "low_count": sum(1 for v in self.vulnerabilities if v["severity"] == "LOW")
        }
        
        # Save summary
        summary_file = Path("loot") / f"vulnerability_scan_{self.device_id}.json"
        summary_file.parent.mkdir(exist_ok=True)
        
        with open(summary_file, 'w') as f:
            json.dump(summary, f, indent=2, default=str)
        
        self.logger.info(f"Vulnerability scan complete: {len(self.vulnerabilities)} vulnerabilities found")
        
        return summary